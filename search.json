[
  {
    "objectID": "api.html",
    "href": "api.html",
    "title": "api",
    "section": "",
    "text": "source\n\nSourceHandler\n\n SourceHandler (*args, **kwargs)\n\nHigh-level API for handling cell source\n\nsource\n\n\nSourceHandler.handle_markdown\n\n SourceHandler.handle_markdown (lines:Sequence[str])\n\nHandle the source lines for a markdown cell\n\n\n\n\nType\nDetails\n\n\n\n\nlines\ntyping.Sequence[str]\nThe lines of source text\n\n\n\n\nsource\n\n\nSourceHandler.handle_python_source\n\n SourceHandler.handle_python_source (lines:Sequence[str])\n\nHandle the source lines for a python code cell\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nlines\ntyping.Sequence[str]\nThe lines of source text\n\n\nReturns\nbool\nIndicates whether the output should be handled for this cell.\n\n\n\n\nsource\n\n\nOutputHandler\n\n OutputHandler (*args, **kwargs)\n\nHigh-level API for handling cell outputs\n\nsource\n\n\nOutputHandler.handle_output\n\n OutputHandler.handle_output (output:Dict)\n\nHandle a single cell output\n\n\n\n\nType\nDetails\n\n\n\n\noutput\ntyping.Dict\na Dict representing a JSON output element as defined in the notebook file format\n\n\nReturns\nTOutputResult\na result whose type is defined by the implementation (typically a callable that completes any asynchronous processing required)\n\n\n\n\nsource\n\n\nhandle_notebook\n\n handle_notebook (nb_json:Dict, source_handler:__main__.SourceHandler,\n                  output_handler:__main__.OutputHandler[+TOutputResult])\n\nHandle a notebook with beetroot\n\n\n\n\nType\nDetails\n\n\n\n\nnb_json\ntyping.Dict\nA Dict representing the content of a notebook as JSON\n\n\nsource_handler\nSourceHandler\nA handler for source elements that conforms to the SourceHandler protocol\n\n\noutput_handler\nmain.OutputHandler[+TOutputResult]\nA handler for output elements that conforms to the OutputHandler protocol\n\n\nReturns\ntyping.Iterable[+TOutputResult]\nAn iterable of results returned from the output handler",
    "crumbs": [
      "api"
    ]
  },
  {
    "objectID": "cli.html",
    "href": "cli.html",
    "title": "cli",
    "section": "",
    "text": "source\n\nbr_export\n\n br_export ()",
    "crumbs": [
      "cli"
    ]
  },
  {
    "objectID": "markdown/transformations.html",
    "href": "markdown/transformations.html",
    "title": "transformations",
    "section": "",
    "text": "source\n\nTransformer\n\n Transformer ()\n\nBase class for all content transformers.\n\nsource\n\n\nTransformer.emit_before\n\n Transformer.emit_before (stream:io.TextIOBase)\n\nImplement this method on sub-classes to emit markdown before the set of lines this transformer processes.\n\nsource\n\n\nTransformer.process_lines\n\n Transformer.process_lines (lines:Sequence[str])\n\nImplement this method on sub-classes to modify the lines this transformer processes.\n\nsource\n\n\nTransformer.emit_after\n\n Transformer.emit_after (stream:io.TextIOBase)\n\nImplement this method on sub-classes to emit markdown after the set of lines this transformer processes.\n\nsource\n\n\nTransformerWithDirectives\n\n TransformerWithDirectives ()\n\nBase class for transformers that use directives.\n\nsource\n\n\nTransformerWithDirectives.begin_using_directives\n\n TransformerWithDirectives.begin_using_directives\n                                                   (directives:Dict[str,Un\n                                                   ion[bool,str,NoneType]]\n                                                   )\n\nFactory function for a context manager that ensures the given directives are cleared after they are used.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndirectives\ntyping.Dict[str, typing.Union[bool, str, NoneType]]\n\n\n\nReturns\nA context manager that will clear the directives after the context\n\n\n\n\n\nsource\n\n\nMultiTransformer\n\n MultiTransformer (transformers:Iterable[__main__.Transformer])\n\nBase class for all content transformers.\n\nsource\n\n\nemit_with_transformation\n\n emit_with_transformation (transformer:__main__.Transformer,\n                           lines:Sequence[str], emit_lines_func:Callable[[\n                           Sequence[str],io.TextIOBase],NoneType],\n                           stream:io.TextIOBase)\n\n\n# Tests for emit_with_transformations()\nclass TransformerA(Transformer):\n    def emit_before(self, stream: io.TextIOBase):\n        stream.write('before A\\n')\n\n    def process_lines(self, lines: Sequence[str]) -&gt; Sequence[str]:\n        return [\n            line.replace('a', 'A')\n            for line in lines\n        ]\n\n    def emit_after(self, stream: io.TextIOBase):\n        stream.write('after A\\n')\n\nclass TransformerB(Transformer):\n    def emit_before(self, stream: io.TextIOBase):\n        stream.write('before B\\n')\n\n    def process_lines(self, lines: Sequence[str]) -&gt; Sequence[str]:\n        return [\n            line.replace('b', 'B')\n            for line in lines\n        ]\n\n    def emit_after(self, stream: io.TextIOBase):\n        stream.write('after B\\n')\n\ndef dummy_emit_lines(lines: Sequence[str], stream: io.TextIOBase):\n    for line in lines:\n        stream.write(line)\n\nlines = [\n    'abCDefab\\n',\n    'ghiAbajkl\\n'\n    'mnoAAAAAABBBBBp\\n'\n]\n\nstream = io.StringIO()\n\nemit_with_transformation(\n    transformer=MultiTransformer([TransformerA(), TransformerB()]),\n    lines=lines,\n    emit_lines_func=dummy_emit_lines,\n    stream=stream\n)\n\nstream.seek(0)\noutput = stream.read()\n\nexpected = \"\"\"\\\nbefore B\nbefore A\nABCDefAB\nghiABAjkl\nmnoAAAAAABBBBBp\nafter A\nafter B\n\"\"\"\n\ntest_eq(output, expected)\n\n\nsource\n\n\nReplaceSingleDollarDelimiters\n\n ReplaceSingleDollarDelimiters ()\n\nTransformer that replaces $ delimiters in inline latex with \\( and \\).\n\n# Test ReplaceSingleDollarDelimiters\n\ninput = [\n    'This is an expression in which the delimiters will be replaced: $a + b$\\n',\n    'These block delimiters should not be replaced: $$a + b$$\\n'\n]\n\noutput = ReplaceSingleDollarDelimiters().process_lines(input)\n\nexpected = [\n    r'This is an expression in which the delimiters will be replaced: \\\\(a + b\\\\)''\\n',\n    'These block delimiters should not be replaced: $$a + b$$\\n'\n]\n\ntest_eq(output, expected)\n\n\nsource\n\n\nEscapeUnderscoresWithinLatexMath\n\n EscapeUnderscoresWithinLatexMath ()\n\nTransformer that replaces underscores within latex math expressions with _.\n\n# Test EscapeUnderscoresWithinLatexMath\n\ntest_cases = [\n    {\n        'name': 'Escape underscores',\n        'lines': ['$a_1 + b_1$\\n'],\n        'expected': ['$a\\_1 + b\\_1$\\n'],\n    },\n    {\n        'name': 'Escape underscores',\n        'lines': ['$$y_1 - x_1$$\\n'],\n        'expected': ['$$y\\_1 - x\\_1$$\\n'],\n    },\n    {\n        'name': 'Leave alone',\n        'lines': ['$a + b$ and $$y - x$$\\n'],\n        'expected': ['$a + b$ and $$y - x$$\\n'],\n    },\n    {\n        'name': 'A block with some newlines',\n        'lines': [\n            '$$\\\\begin{bmatrix}\\n',\n            '{x}_{1,1} & {x}_{1,2} & {x}_{1,3} & {x}_{1,4}\\\\\\\\\\n',\n            '{x}_{2,1} & {x}_{2,2} & {x}_{2,3} & {x}_{2,4}\\\\\\\\\\n',\n            '{x}_{3,1} & {x}_{3,2} & {x}_{3,3} & {x}_{3,4}\\\\\\\\\\n',\n            '{x}_{4,1} & {x}_{4,2} & {x}_{4,3} & {x}_{4,4}\\\\end{bmatrix}\\n',\n            '$$',\n        ],\n        'expected': [\n            '$$\\\\begin{bmatrix}\\n',\n            '{x}\\_{1,1} & {x}\\_{1,2} & {x}\\_{1,3} & {x}\\_{1,4}\\\\\\\\\\n',\n            '{x}\\_{2,1} & {x}\\_{2,2} & {x}\\_{2,3} & {x}\\_{2,4}\\\\\\\\\\n',\n            '{x}\\_{3,1} & {x}\\_{3,2} & {x}\\_{3,3} & {x}\\_{3,4}\\\\\\\\\\n',\n            '{x}\\_{4,1} & {x}\\_{4,2} & {x}\\_{4,3} & {x}\\_{4,4}\\\\end{bmatrix}\\n',\n            '$$',\n        ],\n    },\n    {\n        'name': 'Expressions both in single lines and across lines',\n        'lines': [\n            '$a_1 + b_1$\\n',\n            '$$y_1 - x_1$$\\n' '\\n',\n            '$$\\\\begin{bmatrix}\\n',\n            '{x}_{1,1} & {x}_{1,2} & {x}_{1,3} & {x}_{1,4}\\\\\\\\\\n',\n            '{x}_{2,1} & {x}_{2,2} & {x}_{2,3} & {x}_{2,4}\\\\\\\\\\n',\n            '{x}_{3,1} & {x}_{3,2} & {x}_{3,3} & {x}_{3,4}\\\\\\\\\\n',\n            '{x}_{4,1} & {x}_{4,2} & {x}_{4,3} & {x}_{4,4}\\\\end{bmatrix}\\n',\n            '$$',\n        ],\n        'expected': [\n            '$a\\_1 + b\\_1$\\n',\n            '$$y\\_1 - x\\_1$$\\n' '\\n',\n            '$$\\\\begin{bmatrix}\\n',\n            '{x}\\_{1,1} & {x}\\_{1,2} & {x}\\_{1,3} & {x}\\_{1,4}\\\\\\\\\\n',\n            '{x}\\_{2,1} & {x}\\_{2,2} & {x}\\_{2,3} & {x}\\_{2,4}\\\\\\\\\\n',\n            '{x}\\_{3,1} & {x}\\_{3,2} & {x}\\_{3,3} & {x}\\_{3,4}\\\\\\\\\\n',\n            '{x}\\_{4,1} & {x}\\_{4,2} & {x}\\_{4,3} & {x}\\_{4,4}\\\\end{bmatrix}\\n',\n            '$$',\n        ],\n    },\n    {\n        'name': 'Pathological case: unterminated multi-line block (should not change)',\n        'lines': [\n            '$$\\\\begin{bmatrix}\\n',\n            '{x}_{1,1} & {x}_{1,2} & {x}_{1,3} & {x}_{1,4}\\\\\\\\\\n',\n            '{x}_{2,1} & {x}_{2,2} & {x}_{2,3} & {x}_{2,4}\\\\\\\\\\n',\n            '{x}_{3,1} & {x}_{3,2} & {x}_{3,3} & {x}_{3,4}\\\\\\\\\\n',\n            '{x}_{4,1} & {x}_{4,2} & {x}_{4,3} & {x}_{4,4}\\\\end{bmatrix}\\n',\n        ],\n        'expected': [\n            '$$\\\\begin{bmatrix}\\n',\n            '{x}_{1,1} & {x}_{1,2} & {x}_{1,3} & {x}_{1,4}\\\\\\\\\\n',\n            '{x}_{2,1} & {x}_{2,2} & {x}_{2,3} & {x}_{2,4}\\\\\\\\\\n',\n            '{x}_{3,1} & {x}_{3,2} & {x}_{3,3} & {x}_{3,4}\\\\\\\\\\n',\n            '{x}_{4,1} & {x}_{4,2} & {x}_{4,3} & {x}_{4,4}\\\\end{bmatrix}\\n',\n        ],\n    },\n]\n\nfor tc in test_cases:\n    name = tc['name']\n    lines = tc['lines']\n    expected = tc['expected']\n\n    print(f\"Case: {name}\")\n    output = EscapeUnderscoresWithinLatexMath().process_lines(lines)\n    test_eq(output, expected)\n\nCase: Escape underscores\nCase: Escape underscores\nCase: Leave alone\nCase: A block with some newlines\nCase: Expressions both in single lines and across lines\nCase: Pathological case: unterminated multi-line block (should not change)\n\n\n\nsource\n\n\nEscapeEndLineSlashesWithinLatexMath\n\n EscapeEndLineSlashesWithinLatexMath ()\n\nTransformer that replaces slashes (“\") at the end of lines within math block expressions expressions with”\\“. Handles the case where the”\" is followed by a line width e.g. “[2em]”.\n\n# Test EscapeEndLineSlashesWithinLatexMath\n\ntest_cases = [\n    {\n        'name': 'A block across multiple lines',\n        'lines': [\n            '$$\\\\begin{bmatrix}\\n',\n            '{x}_{1,1} & {x}_{1,2} & {x}_{1,3} & {x}_{1,4}\\\\\\\\\\n',\n            '{x}_{2,1} & {x}_{2,2} & {x}_{2,3} & {x}_{2,4}\\\\\\\\\\n',\n            '{x}_{3,1} & {x}_{3,2} & {x}_{3,3} & {x}_{3,4}\\\\\\\\\\n',\n            '{x}_{4,1} & {x}_{4,2} & {x}_{4,3} & {x}_{4,4}\\\\end{bmatrix}\\n',\n            '$$',\n        ],\n        'expected': [\n            '$$\\\\begin{bmatrix}\\n',\n            '{x}_{1,1} & {x}_{1,2} & {x}_{1,3} & {x}_{1,4}\\\\\\\\\\\\\\\\\\n',\n            '{x}_{2,1} & {x}_{2,2} & {x}_{2,3} & {x}_{2,4}\\\\\\\\\\\\\\\\\\n',\n            '{x}_{3,1} & {x}_{3,2} & {x}_{3,3} & {x}_{3,4}\\\\\\\\\\\\\\\\\\n',\n            '{x}_{4,1} & {x}_{4,2} & {x}_{4,3} & {x}_{4,4}\\\\end{bmatrix}\\n',\n            '$$',\n        ],\n    },\n    {\n        'name': 'A block within a line',\n        'lines': ['A block within a line: $$\\n\\\\begin{bmatrix}\\nx_{1,1}, x_{1, 2}\\\\\\\\\\n\\\\end{bmatrix}\\n$$'],\n        'expected': ['A block within a line: $$\\n\\\\begin{bmatrix}\\nx_{1,1}, x_{1, 2}\\\\\\\\\\\\\\\\\\n\\\\end{bmatrix}\\n$$'],\n    },\n    {\n        'name': r'Line spacing specified at end of line e.g. \\\\[2em]',\n        'lines': [\n            '$$\\n',\n            '\\\\begin{align}\\n',\n            '\\\\frac{\\\\partial \\\\mathcal{L}}{\\\\partial W^{[2]}_{1, 1}} &= \\\\sum_{k, l} \\\\frac{\\\\partial \\\\mathcal{L}}{\\\\partial z^{[2]}_{k, l}}\\\\frac{\\\\partial z^{[2]}_{k, l}}{\\\\partial W^{[2]}_{1, 1}}\\\\\\\\[2em]\\n',\n            '&= \\\\frac{\\\\partial \\\\mathcal{L}}{\\\\partial z^{[2]}_{1, 1}}\\\\frac{\\\\partial z^{[2]}_{1, 1}}{\\\\partial W^{[2]}_{1, 1}} + \\\\frac{\\\\partial \\\\mathcal{L}}{\\\\partial z^{[2]}_{12}}\\\\frac{\\\\partial z^{[2]}_{12}}{\\\\partial W^{[2]}_{1, 1}} + \\\\cdots + \\\\frac{\\\\partial \\\\mathcal{L}}{\\\\partial z^{[2]}_{44}}\\\\frac{\\\\partial z^{[2]}_{44}}{\\\\partial W^{[2]}_{1, 1}} \\n',\n            '\\\\end{align}\\n',\n            '$$\\n',\n        ],\n        'expected': [\n            '$$\\n',\n            '\\\\begin{align}\\n',\n            '\\\\frac{\\\\partial \\\\mathcal{L}}{\\\\partial W^{[2]}_{1, 1}} &= \\\\sum_{k, l} \\\\frac{\\\\partial \\\\mathcal{L}}{\\\\partial z^{[2]}_{k, l}}\\\\frac{\\\\partial z^{[2]}_{k, l}}{\\\\partial W^{[2]}_{1, 1}}\\\\\\\\\\\\\\\\[2em]\\n',\n            '&= \\\\frac{\\\\partial \\\\mathcal{L}}{\\\\partial z^{[2]}_{1, 1}}\\\\frac{\\\\partial z^{[2]}_{1, 1}}{\\\\partial W^{[2]}_{1, 1}} + \\\\frac{\\\\partial \\\\mathcal{L}}{\\\\partial z^{[2]}_{12}}\\\\frac{\\\\partial z^{[2]}_{12}}{\\\\partial W^{[2]}_{1, 1}} + \\\\cdots + \\\\frac{\\\\partial \\\\mathcal{L}}{\\\\partial z^{[2]}_{44}}\\\\frac{\\\\partial z^{[2]}_{44}}{\\\\partial W^{[2]}_{1, 1}} \\n',\n            '\\\\end{align}\\n',\n            '$$\\n',\n        ]\n\n    }\n]\n\nfor tc in test_cases:\n    name = tc['name']\n    lines = tc['lines']\n    expected = tc['expected']\n\n    print(f\"Case: {name}\")\n    output = EscapeEndLineSlashesWithinLatexMath().process_lines(lines)\n    test_eq(output, expected)\n\nCase: A block across multiple lines\nCase: A block within a line\nCase: Line spacing specified at end of line e.g. \\\\[2em]\n\n\n\nsource\n\n\nEscapeEqualsSignsAtLineStartWithinLatexMath\n\n EscapeEqualsSignsAtLineStartWithinLatexMath ()\n\nTransformer that replaces equals signs (“=”) at the start of lines within math block expressions with “=”. This is needed because lines that start with = are sometimes interpreted as headings by markdown.\n\n# Test EscapeEqualsSignsAtLineStartWithinLatexMath\n\ntest_cases = [\n    {\n        'name': 'Basic',\n        'lines': [\n            '$$\\n',\n            '=\\n',\n            '$$\\n',\n        ],\n        'expected': [\n            '$$\\n',\n            '\\=\\n',\n            '$$\\n',\n        ],\n    },\n    {\n        'name': 'Multiple equals',\n        'lines': [\n            '$$\\n',\n            '==\\n',\n            '$$\\n',\n        ],\n        'expected': [\n            '$$\\n',\n            '\\==\\n',\n            '$$\\n',\n        ],\n    },\n    {\n        'name': 'Real example',\n        'lines': [\n            '$$\\n',\n            '\\\\mathbf{B^{[2]}} = \\n',\n            '\\\\def\\\\arraystretch{1.5}\\n',\n            '\\\\begin{bmatrix}\\n',\n            '\\\\mathbf{B^{[2]}_{1, 1}} & \\\\mathbf{B^{[2]}_{1, 2}} & \\\\mathbf{B^{[2]}_{1, 3}} & \\\\mathbf{B^{[2]}_{1, 4}}\\\\\\\\\\n',\n            '\\\\mathbf{B^{[2]}_{2, 1}} & \\\\mathbf{B^{[2]}_{2, 2}} & \\\\mathbf{B^{[2]}_{2, 3}} & \\\\mathbf{B^{[2]}_{2, 4}}\\\\\\\\\\n',\n            '\\\\mathbf{B^{[2]}_{3, 1}} & \\\\mathbf{B^{[2]}_{3, 2}} & \\\\mathbf{B^{[2]}_{3, 3}} & \\\\mathbf{B^{[2]}_{3, 4}}\\\\\\\\\\n',\n            '\\\\mathbf{B^{[2]}_{4, 1}} & \\\\mathbf{B^{[2]}_{4, 2}} & \\\\mathbf{B^{[2]}_{4, 3}} & \\\\mathbf{B^{[2]}_{4, 4}}\\\\\\\\\\n',\n            '\\\\end{bmatrix}\\n',\n            '=\\n',\n            '\\\\begin{bmatrix}\\n',\n            'b^{[2]} & b^{[2]} & b^{[2]} & b^{[2]}\\\\\\\\\\n',\n            'b^{[2]} & b^{[2]} & b^{[2]} & b^{[2]}\\\\\\\\\\n',\n            'b^{[2]} & b^{[2]} & b^{[2]} & b^{[2]}\\\\\\\\\\n',\n            'b^{[2]} & b^{[2]} & b^{[2]} & b^{[2]}\\\\\\\\\\n',\n            '\\\\end{bmatrix}\\n',\n            '$$\\n',\n        ],\n        'expected': [\n            '$$\\n',\n            '\\\\mathbf{B^{[2]}} = \\n',\n            '\\\\def\\\\arraystretch{1.5}\\n',\n            '\\\\begin{bmatrix}\\n',\n            '\\\\mathbf{B^{[2]}_{1, 1}} & \\\\mathbf{B^{[2]}_{1, 2}} & \\\\mathbf{B^{[2]}_{1, 3}} & \\\\mathbf{B^{[2]}_{1, 4}}\\\\\\\\\\n',\n            '\\\\mathbf{B^{[2]}_{2, 1}} & \\\\mathbf{B^{[2]}_{2, 2}} & \\\\mathbf{B^{[2]}_{2, 3}} & \\\\mathbf{B^{[2]}_{2, 4}}\\\\\\\\\\n',\n            '\\\\mathbf{B^{[2]}_{3, 1}} & \\\\mathbf{B^{[2]}_{3, 2}} & \\\\mathbf{B^{[2]}_{3, 3}} & \\\\mathbf{B^{[2]}_{3, 4}}\\\\\\\\\\n',\n            '\\\\mathbf{B^{[2]}_{4, 1}} & \\\\mathbf{B^{[2]}_{4, 2}} & \\\\mathbf{B^{[2]}_{4, 3}} & \\\\mathbf{B^{[2]}_{4, 4}}\\\\\\\\\\n',\n            '\\\\end{bmatrix}\\n',\n            '\\\\=\\n',\n            '\\\\begin{bmatrix}\\n',\n            'b^{[2]} & b^{[2]} & b^{[2]} & b^{[2]}\\\\\\\\\\n',\n            'b^{[2]} & b^{[2]} & b^{[2]} & b^{[2]}\\\\\\\\\\n',\n            'b^{[2]} & b^{[2]} & b^{[2]} & b^{[2]}\\\\\\\\\\n',\n            'b^{[2]} & b^{[2]} & b^{[2]} & b^{[2]}\\\\\\\\\\n',\n            '\\\\end{bmatrix}\\n',\n            '$$\\n',\n        ],\n    },\n    {\n        'name': 'Not within latex math should get left alone',\n        'lines': [\n            'abc',\n            '=\\n',\n            'def',\n        ],\n        'expected': [\n            'abc',\n            '=\\n',\n            'def',\n        ],\n    },\n    {\n        'name': 'Equals not at line start should get left alone',\n        'lines': [\n            '$$\\n',\n            'x = 2 - y\\n',\n            '$$\\n',\n        ],\n        'expected': [\n            '$$\\n',\n            'x = 2 - y\\n',\n            '$$\\n',\n        ],\n    },\n]\n\nfor tc in test_cases:\n    name = tc['name']\n    lines = tc['lines']\n    expected = tc['expected']\n\n    print(f\"Case: {name}\")\n    output = EscapeEqualsSignsAtLineStartWithinLatexMath().process_lines(lines)\n    test_eq(output, expected)\n\nCase: Basic\nCase: Multiple equals\nCase: Real example\nCase: Not within latex math should get left alone\nCase: Equals not at line start should get left alone\n\n\n\nsource\n\n\nUnindent\n\n Unindent ()\n\nTransformer that removes leading indentation from a set of lines. Will determine how far indented the first line is and then remove min(indentation of first non-empty line, indentation of current line) for each subsequent line.\n\n# Test Unindent\n\ntest_cases = [\n    {\n        'name': 'basic',\n        'lines': [\n            '    line 2\\n',\n            '      - line 2\\n',\n            '      - line 3\\n',\n            '    line 4\\n',\n            '      - line 5\\n',\n            'line 6\\n',\n        ],\n        'expected': [\n            'line 2\\n',\n            '  - line 2\\n',\n            '  - line 3\\n',\n            'line 4\\n',\n            '  - line 5\\n',\n            'line 6\\n',\n        ]\n    },\n    {\n        'name': 'all lines are whitespace - leave unmodified',\n        'lines': [\n            '     \\n',\n            '\\n',\n            '  \\n',\n        ],\n        'expected': [\n            '     \\n',\n            '\\n',\n            '  \\n',\n        ]\n    },\n    {\n        'name': 'leading whitespace lines are stripped',\n        'lines': [\n            '     \\n',\n            '\\n',\n            '    line 2\\n',\n            '      - line 2\\n',\n            '      - line 3\\n',\n            '    line 4\\n',\n            '      - line 5\\n',\n            'line 6\\n',\n        ],\n        'expected': [\n            'line 2\\n',\n            '  - line 2\\n',\n            '  - line 3\\n',\n            'line 4\\n',\n            '  - line 5\\n',\n            'line 6\\n',\n        ]\n    }\n\n]\n\nunindent = Unindent()\n\nfor tc in test_cases:\n    name = tc['name']\n    lines = tc['lines']\n    expected = tc['expected']\n\n    print(f\"Case: {name}\")\n    output = unindent.process_lines(lines)\n    test_eq(output, expected)\n\nCase: basic\nCase: all lines are whitespace - leave unmodified\nCase: leading whitespace lines are stripped\n\n\n\nsource\n\n\nCodeFoldTransformer\n\n CodeFoldTransformer ()\n\nTransformer that implements code folding as per Quarto Code Output by emitting the Hugo collapsible shortcode.\n\ntest_cases = [\n    {\n        'name': 'Code fold with no summary',\n        'directives': {\n            'code-fold': True,\n        },\n        'expected': dedent(\n            \"\"\"\\\n            {{% collapsible class=\"code-fold\" summary=\"Code\" %}}\n            {{% /collapsible %}}\n            \"\"\"\n        ),\n    },\n    {\n        'name': 'Code fold with summary',\n        'directives': {\n            'code-fold': True,\n            'code-summary': 'Here is some code'\n        },\n        'expected': dedent(\n            \"\"\"\\\n            {{% collapsible class=\"code-fold\" summary=\"Here is some code\" %}}\n            {{% /collapsible %}}\n            \"\"\"\n        ),\n    },\n    {\n        'name': 'Code fold set to \"show\"',\n        'directives': {\n            'code-fold': 'show',\n            'code-summary': 'Here is some code'\n        },\n        'expected': dedent(\n            \"\"\"\\\n            {{% collapsible class=\"code-fold\" summary=\"Here is some code\" open=1 %}}\n            {{% /collapsible %}}\n            \"\"\"\n        ),\n    },\n    {\n        'name': 'Code fold explicitly false',\n        'directives': {\n            'code-fold': False,\n        },\n        'expected': '',\n    },\n    {\n        'name': 'Code fold set to bogus value',\n        'directives': {\n            'code-fold': 'some bogus value',\n        },\n        'expected': '',\n    },\n    {\n        'name': 'No code fold directive',\n        'directives': {\n            'some-other-directive': False,\n            'yet-another-directive': True,\n        },\n        'expected': '',\n    },\n]\n\nfor tc in test_cases:\n    name = tc['name']\n    directives = tc['directives']\n    expected = tc['expected']\n\n    stream = io.StringIO()\n    transformer = CodeFoldTransformer()\n\n    with transformer.begin_using_directives(directives):\n        transformer.emit_before(stream)\n        transformer.emit_after(stream)\n\n    print(f\"Case: {name}\")\n    stream.seek(0)\n    output = stream.read()\n\n    test_eq(output, expected)\n\nCase: Code fold with no summary\nCase: Code fold with summary\nCase: Code fold set to \"show\"\nCase: Code fold explicitly false\nCase: Code fold set to bogus value\nCase: No code fold directive\n\n\n\nsource\n\n\nRemoveTrailingWhitespaceLeavingFinalNewline\n\n RemoveTrailingWhitespaceLeavingFinalNewline ()\n\nTransformer that removes trailing whitespace but leaves a final newline in place if present.\n\n# Tests for RemoveTrailingWhitespaceLeavingFinalNewline\ntest_cases = [\n    {\n        'name': 'basic',\n        'lines': [\n            'line 1 \\n',\n            '  - line 2   \\n',\n            '  - line 3\\n',\n            'line 4\\t\\n\\n',\n            '  - line 5\\n',\n            'line 6\\n',\n        ],\n        'expected': [\n            'line 1\\n',\n            '  - line 2\\n',\n            '  - line 3\\n',\n            'line 4\\n',\n            '  - line 5\\n',\n            'line 6\\n',\n        ]\n    },\n    {\n        'name': 'no newline but has trailing whitespace',\n        'lines': [\n            'line 1     ',\n        ],\n        'expected': [\n            'line 1',\n        ],\n    },\n    {\n        'name': 'no newline and no trailing whitespace',\n        'lines': [\n            'line 1',\n        ],\n        'expected': [\n            'line 1',\n        ],\n    },\n]\n\ntransformer = RemoveTrailingWhitespaceLeavingFinalNewline()\nfor tc in test_cases:\n    name = tc['name']\n    lines = tc['lines']\n    expected = tc['expected']\n\n    print(f\"Case: {name}\")\n    output = transformer.process_lines(lines)\n    test_eq(output, expected)\n\nCase: basic\nCase: no newline but has trailing whitespace\nCase: no newline and no trailing whitespace",
    "crumbs": [
      "markdown",
      "transformations"
    ]
  },
  {
    "objectID": "markdown/markdown_cli.html",
    "href": "markdown/markdown_cli.html",
    "title": "cli",
    "section": "",
    "text": "source\n\nMarkdownBackendConfig\n\n MarkdownBackendConfig (*args, **kwargs)\n\nBase class for protocol classes.\nProtocol classes are defined as::\nclass Proto(Protocol):\n    def meth(self) -&gt; int:\n        ...\nSuch classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example::\nclass C:\n    def meth(self) -&gt; int:\n        return 0\n\ndef func(x: Proto) -&gt; int:\n    return x.meth()\n\nfunc(C())  # Passes static type check\nSee PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as::\nclass GenProto(Protocol[T]):\n    def meth(self) -&gt; T:\n        ...",
    "crumbs": [
      "markdown",
      "cli"
    ]
  },
  {
    "objectID": "markdown/outputs.html",
    "href": "markdown/outputs.html",
    "title": "outputs",
    "section": "",
    "text": "source\n\nMarkdownOutputHandler\n\n MarkdownOutputHandler (stream:io.TextIOBase, transformers_map:Dict[str,be\n                        etroot.markdown.transformations.Transformer]={})\n\nHigh-level API for handling cell outputs\n\nsource\n\n\nOutputHandler.handle_output\n\n OutputHandler.handle_output (output:Dict)\n\nHandle a single cell output\n\n\n\n\nType\nDetails\n\n\n\n\noutput\ntyping.Dict\na Dict representing a JSON output element as defined in the notebook file format\n\n\nReturns\nTOutputResult\na result whose type is defined by the implementation (typically a callable that completes any asynchronous processing required)\n\n\n\n\nstream_test_cases = [\n    {\n        'name': 'Single line ending in a newline',\n        'stream_output': {\n            'name': 'stdout',\n            'output_type': 'stream',\n            'text': ['hello, world\\n'],\n        },\n        'expected': dedent(\n            \"\"\"\\\n            ```\n            hello, world\n            ```\n\n            \"\"\"\n        )\n    },\n    {\n        'name': 'Single line not ending in a newline',\n        'stream_output': {\n            'name': 'stdout',\n            'output_type': 'stream',\n            'text': ['hello, world'],\n        },\n        'expected': dedent(\n            \"\"\"\\\n            ```\n            hello, world\n            ```\n\n            \"\"\"\n        )\n    },\n    {\n        'name': 'Multiline',\n        'stream_output': {\n            'name': 'stdout',\n            'output_type': 'stream',\n            'text': ['hello, world\\n', 'a second line\\n', 'a third line\\n'],\n        },\n        'expected': dedent(\n            \"\"\"\\\n            ```\n            hello, world\n            a second line\n            a third line\n            ```\n\n            \"\"\"\n        )\n    }\n]\n\nfor case in stream_test_cases:\n    name = case['name']\n    stream_output = case['stream_output']\n    expected = case['expected']\n\n    stream = io.StringIO()\n    output_handler = MarkdownOutputHandler(stream)\n    output_handler.handle_output(stream_output)\n\n    stream.seek(0)\n    output = stream.read()\n\n    test_eq(output, expected)\n    print(f\"Case: {name}\")\n    print(output)\n\nCase: Single line ending in a newline\n```\nhello, world\n```\n\n\nCase: Single line not ending in a newline\n```\nhello, world\n```\n\n\nCase: Multiline\n```\nhello, world\na second line\na third line\n```\n\n\n\n\n\nexecution_result_test_cases = [\n    {\n        'name': 'Markdown',\n        'execute_result_output': {\n            'output_type': 'execute_result',\n            'data': {\n                'text/markdown': [\n                    '$$\\\\begin{bmatrix}\\n',\n                    '{x}_{1,1} & {x}_{1,2} & {x}_{1,3} & {x}_{1,4}\\\\\\\\\\n',\n                    '{x}_{2,1} & {x}_{2,2} & {x}_{2,3} & {x}_{2,4}\\\\\\\\\\n',\n                    '{x}_{3,1} & {x}_{3,2} & {x}_{3,3} & {x}_{3,4}\\\\\\\\\\n',\n                    '{x}_{4,1} & {x}_{4,2} & {x}_{4,3} & {x}_{4,4}\\\\end{bmatrix}\\n',\n                    '$$',\n                ],\n                'text/plain': ['&lt;IPython.core.display.Markdown object&gt;'],\n            },\n        },\n        'expected': dedent(\n            \"\"\"\\\n            $$\\\\begin{bmatrix}\n            {x}_{1,1} & {x}_{1,2} & {x}_{1,3} & {x}_{1,4}\\\\\\\\\n            {x}_{2,1} & {x}_{2,2} & {x}_{2,3} & {x}_{2,4}\\\\\\\\\n            {x}_{3,1} & {x}_{3,2} & {x}_{3,3} & {x}_{3,4}\\\\\\\\\n            {x}_{4,1} & {x}_{4,2} & {x}_{4,3} & {x}_{4,4}\\\\end{bmatrix}\n            $$\n\n            \"\"\"\n        ),\n    },\n    {\n        'name': 'Latex',\n        'execute_result_output': {\n            'output_type': 'execute_result',\n            'data': {\n                'text/latex': [\n                    '$\\\\displaystyle b^{[2]} + {W^{[2]}}_{1,1} {a^{[1]}}_{1,1} + {W^{[2]}}_{1,2} {a^{[1]}}_{1,2} + {W^{[2]}}_{1,3} {a^{[1]}}_{1,3} + {W^{[2]}}_{2,1} {a^{[1]}}_{2,1} + {W^{[2]}}_{2,2} {a^{[1]}}_{2,2} + {W^{[2]}}_{2,3} {a^{[1]}}_{2,3} + {W^{[2]}}_{3,1} {a^{[1]}}_{3,1} + {W^{[2]}}_{3,2} {a^{[1]}}_{3,2} + {W^{[2]}}_{3,3} {a^{[1]}}_{3,3}$'\n                ],\n                'text/plain': [\n                    'b^{[2]} + W^{[2]}[1, 1]*a^{[1]}[1, 1] + W^{[2]}[1, 2]*a^{[1]}[1, 2] + W^{[2]}[1, 3]*a^{[1]}[1, 3] + W^{[2]}[2, 1]*a^{[1]}[2, 1] + W^{[2]}[2, 2]*a^{[1]}[2, 2] + W^{[2]}[2, 3]*a^{[1]}[2, 3] + W^{[2]}[3, 1]*a^{[1]}[3, 1] + W^{[2]}[3, 2]*a^{[1]}[3, 2] + W^{[2]}[3, 3]*a^{[1]}[3, 3]'\n                ],\n            },\n        },\n        'expected': dedent(\n            \"\"\"\\\n            $\\\\displaystyle b^{[2]} + {W^{[2]}}_{1,1} {a^{[1]}}_{1,1} + {W^{[2]}}_{1,2} {a^{[1]}}_{1,2} + {W^{[2]}}_{1,3} {a^{[1]}}_{1,3} + {W^{[2]}}_{2,1} {a^{[1]}}_{2,1} + {W^{[2]}}_{2,2} {a^{[1]}}_{2,2} + {W^{[2]}}_{2,3} {a^{[1]}}_{2,3} + {W^{[2]}}_{3,1} {a^{[1]}}_{3,1} + {W^{[2]}}_{3,2} {a^{[1]}}_{3,2} + {W^{[2]}}_{3,3} {a^{[1]}}_{3,3}$\n\n            \"\"\"\n        ),\n    },\n    {\n        'name': 'HTML',\n        'execute_result_output': {\n            'output_type': 'execute_result',\n            'data': {\n                'text/html': [\n                    '\\n',\n                    '        &lt;iframe\\n',\n                    '            width=\\\"400\\\"\\n',\n                    '            height=\\\"300\\\"\\n',\n                    '            src=\\\"https://www.youtube.com/embed/Y7eoO3hZQYY?loop=1&mute=1&playlist=Y7eoO3hZQYY&autoplay=1\\\"\\n',\n                    '            frameborder=\\\"0\\\"\\n',\n                    '            allowfullscreen\\n',\n                    '            allow=\\\"autoplay\\\"\\n',\n                    '        &gt;&lt;/iframe&gt;\\n',\n                    '        ',\n                ],\n                'text/plain': ['&lt;IPython.lib.display.YouTubeVideo&gt;'],\n            },\n        },\n        'expected': (\n            '\\n'\n            '        &lt;iframe\\n'\n            '            width=\\\"400\\\"\\n'\n            '            height=\\\"300\\\"\\n'\n            '            src=\\\"https://www.youtube.com/embed/Y7eoO3hZQYY?loop=1&mute=1&playlist=Y7eoO3hZQYY&autoplay=1\\\"\\n'\n            '            frameborder=\\\"0\\\"\\n'\n            '            allowfullscreen\\n'\n            '            allow=\\\"autoplay\\\"\\n'\n            '        &gt;&lt;/iframe&gt;\\n'\n            '        \\n\\n'\n        ),\n    },\n    {\n        'name': 'Plaintext',\n        'execute_result_output': {\n            'output_type': 'execute_result',\n            'data': {\n                'text/plain': [\n                    'array([[w_{11}*x_{11} + w_{12}*x_{12} + w_{21}*x_{21} + w_{22}*x_{22},\\n',\n                    '        w_{11}*x_{12} + w_{12}*x_{13} + w_{21}*x_{22} + w_{22}*x_{23},\\n',\n                    '        w_{11}*x_{13} + w_{12}*x_{14} + w_{21}*x_{23} + w_{22}*x_{24}],\\n',\n                    '       [w_{11}*x_{21} + w_{12}*x_{22} + w_{21}*x_{31} + w_{22}*x_{32},\\n',\n                    '        w_{11}*x_{22} + w_{12}*x_{23} + w_{21}*x_{32} + w_{22}*x_{33},\\n',\n                    '        w_{11}*x_{23} + w_{12}*x_{24} + w_{21}*x_{33} + w_{22}*x_{34}],\\n',\n                    '       [w_{11}*x_{31} + w_{12}*x_{32} + w_{21}*x_{41} + w_{22}*x_{42},\\n',\n                    '        w_{11}*x_{32} + w_{12}*x_{33} + w_{21}*x_{42} + w_{22}*x_{43},\\n',\n                    '        w_{11}*x_{33} + w_{12}*x_{34} + w_{21}*x_{43} + w_{22}*x_{44}]],\\n',\n                    '      dtype=object)',\n                ]\n            },\n        },\n        'expected': dedent(\n            \"\"\"\\\n            ```\n            array([[w_{11}*x_{11} + w_{12}*x_{12} + w_{21}*x_{21} + w_{22}*x_{22},\n                    w_{11}*x_{12} + w_{12}*x_{13} + w_{21}*x_{22} + w_{22}*x_{23},\n                    w_{11}*x_{13} + w_{12}*x_{14} + w_{21}*x_{23} + w_{22}*x_{24}],\n                   [w_{11}*x_{21} + w_{12}*x_{22} + w_{21}*x_{31} + w_{22}*x_{32},\n                    w_{11}*x_{22} + w_{12}*x_{23} + w_{21}*x_{32} + w_{22}*x_{33},\n                    w_{11}*x_{23} + w_{12}*x_{24} + w_{21}*x_{33} + w_{22}*x_{34}],\n                   [w_{11}*x_{31} + w_{12}*x_{32} + w_{21}*x_{41} + w_{22}*x_{42},\n                    w_{11}*x_{32} + w_{12}*x_{33} + w_{21}*x_{42} + w_{22}*x_{43},\n                    w_{11}*x_{33} + w_{12}*x_{34} + w_{21}*x_{43} + w_{22}*x_{44}]],\n                  dtype=object)\n            ```\n\n            \"\"\"\n        ),\n    },\n]\n\n\nfor case in execution_result_test_cases:\n    name = case['name']\n    execute_result_output = case['execute_result_output']\n    expected = case['expected']\n\n    stream = io.StringIO()\n    output_handler = MarkdownOutputHandler(stream)\n    output_handler.handle_output(execute_result_output)\n\n    stream.seek(0)\n    output = stream.read()\n\n    test_eq(output, expected)\n    print(f\"Case: {name}\")\n    print(output)\n\nCase: Markdown\n$$\\begin{bmatrix}\n{x}_{1,1} & {x}_{1,2} & {x}_{1,3} & {x}_{1,4}\\\\\n{x}_{2,1} & {x}_{2,2} & {x}_{2,3} & {x}_{2,4}\\\\\n{x}_{3,1} & {x}_{3,2} & {x}_{3,3} & {x}_{3,4}\\\\\n{x}_{4,1} & {x}_{4,2} & {x}_{4,3} & {x}_{4,4}\\end{bmatrix}\n$$\n\n\nCase: Latex\n$\\displaystyle b^{[2]} + {W^{[2]}}_{1,1} {a^{[1]}}_{1,1} + {W^{[2]}}_{1,2} {a^{[1]}}_{1,2} + {W^{[2]}}_{1,3} {a^{[1]}}_{1,3} + {W^{[2]}}_{2,1} {a^{[1]}}_{2,1} + {W^{[2]}}_{2,2} {a^{[1]}}_{2,2} + {W^{[2]}}_{2,3} {a^{[1]}}_{2,3} + {W^{[2]}}_{3,1} {a^{[1]}}_{3,1} + {W^{[2]}}_{3,2} {a^{[1]}}_{3,2} + {W^{[2]}}_{3,3} {a^{[1]}}_{3,3}$\n\n\nCase: HTML\n\n        &lt;iframe\n            width=\"400\"\n            height=\"300\"\n            src=\"https://www.youtube.com/embed/Y7eoO3hZQYY?loop=1&mute=1&playlist=Y7eoO3hZQYY&autoplay=1\"\n            frameborder=\"0\"\n            allowfullscreen\n            allow=\"autoplay\"\n        &gt;&lt;/iframe&gt;\n        \n\n\nCase: Plaintext\n```\narray([[w_{11}*x_{11} + w_{12}*x_{12} + w_{21}*x_{21} + w_{22}*x_{22},\n        w_{11}*x_{12} + w_{12}*x_{13} + w_{21}*x_{22} + w_{22}*x_{23},\n        w_{11}*x_{13} + w_{12}*x_{14} + w_{21}*x_{23} + w_{22}*x_{24}],\n       [w_{11}*x_{21} + w_{12}*x_{22} + w_{21}*x_{31} + w_{22}*x_{32},\n        w_{11}*x_{22} + w_{12}*x_{23} + w_{21}*x_{32} + w_{22}*x_{33},\n        w_{11}*x_{23} + w_{12}*x_{24} + w_{21}*x_{33} + w_{22}*x_{34}],\n       [w_{11}*x_{31} + w_{12}*x_{32} + w_{21}*x_{41} + w_{22}*x_{42},\n        w_{11}*x_{32} + w_{12}*x_{33} + w_{21}*x_{42} + w_{22}*x_{43},\n        w_{11}*x_{33} + w_{12}*x_{34} + w_{21}*x_{43} + w_{22}*x_{44}]],\n      dtype=object)\n```\n\n\n\n\n\n# Tests for the image case\n\n# Load some image data from disk:\nnbpath = os.path.dirname(os.path.realpath('__file__')) # Get path to this notebook\nimage_data_b64 = (Path(nbpath) / '../../test_artifacts' / 'test_image_base64.txt').read_text()\n\nstream = io.StringIO()\ndummy_filename = 'abcdef'\n\ncompletion = emit_image_data(image_data_b64, stream, filename_generator=lambda _: dummy_filename)\nstream.seek(0)\noutput = stream.read()\n\nexpected_filename = f'images/{dummy_filename}.png'\n\ntest_eq(output, f'![]({expected_filename})')\n\nwith tempfile.TemporaryDirectory() as tmpdir:\n    tmp_path = Path(tmpdir)\n    completion(Path(tmp_path))\n    test_eq((tmp_path / expected_filename).is_file(), True)\n\n    print(\"Displaying file that was written to disk:\")\n    display(Image(filename=tmp_path / expected_filename))\n\nDisplaying file that was written to disk:\n\n\n\n\n\n\n\n\n\n\ndisplay_data_test_cases = [\n    {\n        'name': tc['name'],\n        'display_data_output': {\n            'output_type': 'display_data',\n            'data': tc['execute_result_output']['data']\n        },\n        'expected': tc['expected']\n    } for tc in execution_result_test_cases\n]\n\nfor case in display_data_test_cases:\n    name = case['name']\n    display_data_output = case['display_data_output']\n    expected = case['expected']\n\n    stream = io.StringIO()\n    output_handler = MarkdownOutputHandler(stream)\n    output_handler.handle_output(display_data_output)\n\n    stream.seek(0)\n    output = stream.read()\n\n    test_eq(output, expected)\n    print(f\"Case: {name}\")\n    print(output)\n\nCase: Markdown\n$$\\begin{bmatrix}\n{x}_{1,1} & {x}_{1,2} & {x}_{1,3} & {x}_{1,4}\\\\\n{x}_{2,1} & {x}_{2,2} & {x}_{2,3} & {x}_{2,4}\\\\\n{x}_{3,1} & {x}_{3,2} & {x}_{3,3} & {x}_{3,4}\\\\\n{x}_{4,1} & {x}_{4,2} & {x}_{4,3} & {x}_{4,4}\\end{bmatrix}\n$$\n\n\nCase: Latex\n$\\displaystyle b^{[2]} + {W^{[2]}}_{1,1} {a^{[1]}}_{1,1} + {W^{[2]}}_{1,2} {a^{[1]}}_{1,2} + {W^{[2]}}_{1,3} {a^{[1]}}_{1,3} + {W^{[2]}}_{2,1} {a^{[1]}}_{2,1} + {W^{[2]}}_{2,2} {a^{[1]}}_{2,2} + {W^{[2]}}_{2,3} {a^{[1]}}_{2,3} + {W^{[2]}}_{3,1} {a^{[1]}}_{3,1} + {W^{[2]}}_{3,2} {a^{[1]}}_{3,2} + {W^{[2]}}_{3,3} {a^{[1]}}_{3,3}$\n\n\nCase: HTML\n\n        &lt;iframe\n            width=\"400\"\n            height=\"300\"\n            src=\"https://www.youtube.com/embed/Y7eoO3hZQYY?loop=1&mute=1&playlist=Y7eoO3hZQYY&autoplay=1\"\n            frameborder=\"0\"\n            allowfullscreen\n            allow=\"autoplay\"\n        &gt;&lt;/iframe&gt;\n        \n\n\nCase: Plaintext\n```\narray([[w_{11}*x_{11} + w_{12}*x_{12} + w_{21}*x_{21} + w_{22}*x_{22},\n        w_{11}*x_{12} + w_{12}*x_{13} + w_{21}*x_{22} + w_{22}*x_{23},\n        w_{11}*x_{13} + w_{12}*x_{14} + w_{21}*x_{23} + w_{22}*x_{24}],\n       [w_{11}*x_{21} + w_{12}*x_{22} + w_{21}*x_{31} + w_{22}*x_{32},\n        w_{11}*x_{22} + w_{12}*x_{23} + w_{21}*x_{32} + w_{22}*x_{33},\n        w_{11}*x_{23} + w_{12}*x_{24} + w_{21}*x_{33} + w_{22}*x_{34}],\n       [w_{11}*x_{31} + w_{12}*x_{32} + w_{21}*x_{41} + w_{22}*x_{42},\n        w_{11}*x_{32} + w_{12}*x_{33} + w_{21}*x_{42} + w_{22}*x_{43},\n        w_{11}*x_{33} + w_{12}*x_{34} + w_{21}*x_{43} + w_{22}*x_{44}]],\n      dtype=object)\n```",
    "crumbs": [
      "markdown",
      "outputs"
    ]
  },
  {
    "objectID": "markdown/markdown_api.html",
    "href": "markdown/markdown_api.html",
    "title": "api",
    "section": "",
    "text": "# Import things only used in tests and not exported\nfrom beetroot.markdown.transformations import (\n    CodeFoldTransformer,\n    EscapeEndLineSlashesWithinLatexMath,\n    EscapeUnderscoresWithinLatexMath,\n    MultiTransformer,\n    RemoveTrailingWhitespaceLeavingFinalNewline,\n    ReplaceSingleDollarDelimiters,\n    Unindent,\n)\nsource",
    "crumbs": [
      "markdown",
      "api"
    ]
  },
  {
    "objectID": "markdown/markdown_api.html#test-transformations",
    "href": "markdown/markdown_api.html#test-transformations",
    "title": "api",
    "section": "Test Transformations",
    "text": "Test Transformations\n\n# Form the path to the testcase notebook\nnbpath = os.path.dirname(os.path.realpath('__file__'))  # Get path to this notebook\ntest_nb_path = (\n    Path(nbpath) / '../../test_artifacts' / 'transformations_testcases.ipynb'\n)\n\n# Load the testcase notebook as JSON\nnb_json = json.loads(test_nb_path.read_text())\n\n# Setup transformers\ntransformer = MultiTransformer([\n    EscapeUnderscoresWithinLatexMath(),\n    EscapeEndLineSlashesWithinLatexMath(),\n    RemoveTrailingWhitespaceLeavingFinalNewline(),\n    ReplaceSingleDollarDelimiters()\n])\n\n# Export\nmd_text, _ = export_markdown_notebook(\n    nb_json,\n    markdown_source_transformer=transformer,\n    python_source_transformer=CodeFoldTransformer(),\n    output_transformers_map={\n        'text/markdown/data/output': transformer,\n        'text/latex/data/output': transformer,\n        'text/html/data/output': Unindent(),\n    }\n)\n\nMarkdown(md_text)\n\nThis is some markdown in which I will replace the dollar signs in the following inline expression: \\(a + b\\).\nfrom IPython.display import Markdown, Latex, YouTubeVideo\nMarkdown('This is output markdown in which I will replace the dollar signs in the following inline expression: $a + b$.')\nThis is output markdown in which I will replace the dollar signs in the following inline expression: \\(a + b\\).\nI do not want these block delimiters replaced: \\[a + b\\]\nLatex('$\\\\displaystyle w_{11} x_{11} + w_{12} x_{12} + w_{21} x_{21} + w_{22} x_{22}$')\n\\(w_{11} x_{11} + w_{12} x_{12} + w_{21} x_{21} + w_{22} x_{22}\\)\n# The html produced by this should be unindented\nvideo_id = 'Y7eoO3hZQYY'\nYouTubeVideo(video_id, allow_autoplay=True, loop=1, mute=1, playlist=video_id)\n\n\n# Test fixing up of matrices:\n\ntext = ''.join([\n    '$$\\\\begin{bmatrix}\\n',\n    '{x}_{1,1} & {x}_{1,2} & {x}_{1,3} & {x}_{1,4}\\\\\\\\\\n',\n    '{x}_{2,1} & {x}_{2,2} & {x}_{2,3} & {x}_{2,4}\\\\\\\\\\n',\n    '{x}_{3,1} & {x}_{3,2} & {x}_{3,3} & {x}_{3,4}\\\\\\\\\\n',\n    '{x}_{4,1} & {x}_{4,2} & {x}_{4,3} & {x}_{4,4}\\\\end{bmatrix}\\n',\n    '$$'\n])\n\nMarkdown(text)\n\\[\\begin{bmatrix}\n{x}\\_{1,1} & {x}\\_{1,2} & {x}\\_{1,3} & {x}\\_{1,4}\\\\\\\\\n{x}\\_{2,1} & {x}\\_{2,2} & {x}\\_{2,3} & {x}\\_{2,4}\\\\\\\\\n{x}\\_{3,1} & {x}\\_{3,2} & {x}\\_{3,3} & {x}\\_{3,4}\\\\\\\\\n{x}\\_{4,1} & {x}\\_{4,2} & {x}\\_{4,3} & {x}\\_{4,4}\\end{bmatrix}\n\\]\n{{% collapsible class=“code-fold” summary=“Code” %}}\n# This code should get wrapped in a collapsible short code\nprint(\"Hello, world!\")\n{{% /collapsible %}}\n{{% collapsible class=“code-fold” summary=“This is my summary” %}}\n# This code should get wrapped in a collapsible short code with\n# a custom summary value\nprint(\"Hello, world!\")\n{{% /collapsible %}}\n{{% collapsible class=“code-fold” summary=“This is my summary” open=1 %}}\n# This code should get wrapped in a collapsible short code with\n# a custom summary value and have the open param set to 1\nprint(\"Hello, world!\")\n{{% /collapsible %}}\nHere’s a markdown cell with one line and trailing whitespace, which should get stripped.\nHere’s a markdown cell with multiple lines, Some of which have trailing whitespace, which should all be stripped.\nHere’s a markdown cell with one line and no trailing whitespace.",
    "crumbs": [
      "markdown",
      "api"
    ]
  },
  {
    "objectID": "markdown/source.html",
    "href": "markdown/source.html",
    "title": "source",
    "section": "",
    "text": "# Tests for interpret_directives\ntest_cases = [\n    {\n        'name': 'No directives',\n        'directives': {},\n        'expected_should_echo': True,\n        'expected_should_show_output': True,\n    },\n    {\n        'name': 'Echo false',\n        'directives': {'echo': False},\n        'expected_should_echo': False,\n        'expected_should_show_output': True,\n    },\n    {\n        'name': 'Echo true',\n        'directives': {'echo': True},\n        'expected_should_echo': True,\n        'expected_should_show_output': True,\n    },\n    {\n        'name': 'Output false',\n        'directives': {'output': False},\n        'expected_should_echo': True,\n        'expected_should_show_output': False,\n    },\n    {\n        'name': 'Output true',\n        'directives': {'output': True},\n        'expected_should_echo': True,\n        'expected_should_show_output': True,\n    },\n    {\n        'name': 'Hide only',\n        'directives': {'hide': None},\n        'expected_should_echo': False,\n        'expected_should_show_output': False,\n    },\n    # There are other weird cases like hide and echo: true, but these\n    # should not happen in practice and I don't want to have tests for\n    # the arbitrary behavior that would happen.\n]\n\nfor tc in test_cases:\n    name = tc['name']\n    directives = tc['directives']\n    expected_should_echo = tc['expected_should_echo']\n    expected_should_show_output = tc['expected_should_show_output']\n\n    print(f\"Running test case: {name}\")\n    should_echo, should_show_output = interpret_directives(directives)\n\n    test_eq(should_echo, expected_should_echo)\n    test_eq(should_show_output, expected_should_show_output)\n\nRunning test case: No directives\nRunning test case: Echo false\nRunning test case: Echo true\nRunning test case: Output false\nRunning test case: Output true\nRunning test case: Hide only\n\n\n\nsource\n\nMarkdownSourceHandler\n\n MarkdownSourceHandler (stream:io.TextIOBase, markdown_source_transformer:\n                        beetroot.markdown.transformations.Transformer=&lt;bee\n                        troot.markdown.transformations.Transformer object\n                        at 0x7f03bcec2af0&gt;, python_source_transformer:beet\n                        root.markdown.transformations.TransformerWithDirec\n                        tives=&lt;beetroot.markdown.transformations.Transform\n                        erWithDirectives object at 0x7f03bcec2a00&gt;)\n\nHigh-level API for handling cell source\n\nsource\n\n\nMarkdownSourceHandler.handle_markdown\n\n MarkdownSourceHandler.handle_markdown (lines:Sequence[str])\n\nHandle the source lines for a markdown cell\n\n\n\n\nType\nDetails\n\n\n\n\nlines\ntyping.Sequence[str]\nThe lines of source text\n\n\n\n\nmarkdown_source = [\n    '# This is Markdown\\n',\n    'This is a [link](https://www.google.com).\\n',\n    'This is:\\n',\n    '\\n',\n    '* a \\n',\n    '* bulleted\\n',\n    '* list\\n',\n    '\\n',\n    'Yup.',\n]\nstream = io.StringIO()\nsrc_handler = MarkdownSourceHandler(stream)\n\nsrc_handler.handle_markdown(markdown_source)\n\nstream.seek(0)\noutput = stream.read()\n\nexpected = \"\"\"\\\n# This is Markdown\nThis is a [link](https://www.google.com).\nThis is:\n\n* a\"\"\" + \" \" + \"\"\"\n* bulleted\n* list\n\nYup.\n\n\"\"\"\n\ntest_eq(output, expected)\nprint(output)\n\n# This is Markdown\nThis is a [link](https://www.google.com).\nThis is:\n\n* a \n* bulleted\n* list\n\nYup.\n\n\n\n\n\nsource\n\n\nMarkdownSourceHandler.handle_python_source\n\n MarkdownSourceHandler.handle_python_source (lines:Sequence[str])\n\nHandle the source lines for a python code cell\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nlines\ntyping.Sequence[str]\nThe lines of source text\n\n\nReturns\nbool\nIndicates whether the output should be handled for this cell.\n\n\n\n\npython_source = ['name = \\'world\\'\\n', 'print(f\"hello, {name}\")']\n\nstream = io.StringIO()\nsrc_handler = MarkdownSourceHandler(stream)\n\nshould_show_output = src_handler.handle_python_source(python_source)\n\nstream.seek(0)\noutput = stream.read()\n\nexpected = \"\"\"\\\n```python\nname = 'world'\nprint(f\"hello, {name}\")\n```\n\n\"\"\"\n\ntest_eq(output, expected)\ntest_eq(should_show_output, True)\nprint(output)\n\n```python\nname = 'world'\nprint(f\"hello, {name}\")\n```",
    "crumbs": [
      "markdown",
      "source"
    ]
  },
  {
    "objectID": "backend_config.html",
    "href": "backend_config.html",
    "title": "backend_config",
    "section": "",
    "text": "source\n\nBackendConfig\n\n BackendConfig (*args, **kwargs)\n\nBase class for protocol classes.\nProtocol classes are defined as::\nclass Proto(Protocol):\n    def meth(self) -&gt; int:\n        ...\nSuch classes are primarily used with static type checkers that recognize structural subtyping (static duck-typing), for example::\nclass C:\n    def meth(self) -&gt; int:\n        return 0\n\ndef func(x: Proto) -&gt; int:\n    return x.meth()\n\nfunc(C())  # Passes static type check\nSee PEP 544 for details. Protocol classes decorated with @typing.runtime_checkable act as simple-minded runtime protocols that check only the presence of given attributes, ignoring their type signatures. Protocol classes can be generic, they are defined as::\nclass GenProto(Protocol[T]):\n    def meth(self) -&gt; T:\n        ...",
    "crumbs": [
      "backend_config"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "beetroot",
    "section": "",
    "text": "pip install beetroot",
    "crumbs": [
      "beetroot"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "beetroot",
    "section": "",
    "text": "pip install beetroot",
    "crumbs": [
      "beetroot"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "beetroot",
    "section": "How to use",
    "text": "How to use\nFrom the command-line, using the markdown backend:\nbr_export --backend markdown path/to/notebook.ipynb path/to/output_directory\nAs a Python API:\n\nimport json\nfrom pathlib import Path\n\nfrom beetroot.markdown.api import export_markdown_notebook\n\n# Input and output paths\nnb_path = Path('path/to/notebook.ipynb')\noutput_path = Path('path/to/output/directory')\n\n# Load the notebook contents as JSON\nnb_json = json.loads(nb_path.read_text())\n\n# Export the notebook\nmarkdown, completions = export_markdown_notebook(nb_json)\n\n# Run the completion to write all external files\nfor completion in completions:\n    completion(output_path)\n\n# Write the markdown to an output file\nmd_filename = output_path / nb_path.with_suffix('.md').name\nwith open(md_filename, 'w') as md_file:\n    md_file.write(markdown)",
    "crumbs": [
      "beetroot"
    ]
  },
  {
    "objectID": "index.html#dev-environment-setup",
    "href": "index.html#dev-environment-setup",
    "title": "beetroot",
    "section": "Dev Environment Setup",
    "text": "Dev Environment Setup\n\nCreate a virtual environment for beetroot development:\n\npython3 -m venv ~/venv/venv-beetroot-dev\nsource ~/venv/venv-beetroot-dev/bin/activate\n\nInstall requirements\n\npip install -r requirements.dev.txt\n\nBefore committing changes\nRun the following to ensure all dependencies are generated from notebooks and notebooks are cleaned:\nnbdev_export && mypy beetroot/ && nbdev_test && nbdev_clean && nbdev_clean --fname test_artifacts/ && nbdev_readme\n\n\nUseful Tricks\nSearch for a string in all python files (.ipynb and .py files):\nfind . -name '_proc' -prune -o \\( -name '*.ipynb' -o -name '*.py' \\) -type f -exec grep -nH 'export_notebook' {} \\;",
    "crumbs": [
      "beetroot"
    ]
  }
]